# Анянов Кирилл ИТ-4 Лабораторная №3

# Задание 1
## Задача 4
### Текст задачи
Измените сущность Дробь из задачи 1.5.5. Реализуйте следующие требования: 
• Дробь не может быть изменена после создания 
• Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель 
не может быть отрицательным.  
Продемонстрируйте работоспособность решения на примерах. 
### Алгоритм решения
Создаем неизменяемый класс Fraction с final полями numerator и denominator
В конструкторе проверяем, что знаменатель не равен нулю
Обрабатываем отрицательные значения: если знаменатель отрицательный, меняем знаки числителя и знаменателя
Сокращаем дробь с помощью алгоритма Евклида для нахождения НОД
Реализуем арифметические операции (сложение, вычитание, умножение, деление) с созданием новых объектов
Наследуемся от класса Number и реализуем его методы преобразования к примитивным типам

## Задача 10
### Текст задачи
Измените сущности из задачи 1.3.3. Гарантируйте, что между двумя городами может быть только 
одна прямая дорога (другой путь может быть проложен только транзитом через другие города). 
Города можно создавать с указанием заранее заданных путей, в любой момент времени можно 
добавить новую дорогу в любой город и удалить имеющуюся дорогу. 
### Алгоритм решения
Создаем класс City с Map<City, Integer> для хранения дорог к другим городам
Гарантируем уникальность дорог через проверку наличия связи перед добавлением
При добавлении дороги создаем двустороннюю связь между городами
При удалении дороги удаляем связь с обеих сторон
Конструкторы позволяют создавать города как с пустыми дорогами, так и с предустановленными

# Задание 2
## Задача 5
### Текст задачи
Данная задача предполагает разработку новой сущности на основе той, что была получена в 
задаче 1.4.8 (Город). Сущность Город может быть доработана по своему усмотрению для более 
удобного использования. 
Основная идея задачи в разработке такой сущности, которая будет представлять собой маршрут 
между двумя городами. Данный маршрут в любой момент времени можно получить как массив 
для дальнейшего использования. Сущность Маршрут имеет следующие характеристики: 
• Имеет Город начала и Город конца пути.  
• Инициализация Маршрута может быть выполнена только если указана точка начала и 
конца пути. Если указано nullзначение  - то ошибка. 
• Точку начала и конца можно изменить в любой момент времени, но они всегда должны 
существовать. 
• Может вернуть массив Городов, представляющий собой маршрут из начала в конец. 
Массив содержит все Города (в порядке очереди) через которые надо пройти что бы 
попасть из Города начала в Город конца, причем и начало и конец также содержатся в 
этом массиве. Алгоритм формирования пути в данном случае не существенен, можно 
выбрать вариант со случайным путем, путем проходящим через наименьшее число 
городов, или самым дешевым путем. Если путь найти невозможно – возвращается пустой 
массив.  
• Маршрут может быть приведен к строке, которая будет возвращать название всех 
городов маршрута в порядке очередности. 
• Создание объекта и изменение точек начала и конца выполняется за константное время 
O(1). 
Воспользуйтесь картой городов из задачи 1.3.3 и выведите маршрут из Города F в Город D 
### Алгоритм решения
Создаем класс Route с полями start и end (города начала и конца)
Реализуем проверку на null при инициализации и изменении точек маршрута
Для поиска пути используем алгоритм BFS (поиск в ширину) для нахождения кратчайшего пути по количеству городов
Восстанавливаем путь с помощью HashMap, хранящей предыдущие города
Метод getRoute() возвращает массив городов пути или пустой массив если путь не найден
Переопределяем toString() для красивого строкового представления маршрута

# Задание 3
## Задача 1
### Текст задачи
Измените сущность Дробь, полученную в задаче 2.1.4. Гарантируйте, что невозможно создать 
такой подвид дроби, который позволял бы создавать Дроби с изменяемым состоянием. 
### Алгоритм решения
Объявляем класс Fraction как final чтобы запретить наследование
Все поля (numerator, denominator) объявляем как final
Не предоставляем методов для изменения состояния после создания
Все арифметические операции возвращают новые объекты Fraction

# Задание 4
## Задача 2
### Текст задачи
Измените сущность Дробь, полученную в задаче 2.3.1. Дробь должна быть подтипом класса 
Number. Данный класс входит в стандартную редакцию языка Java. 
### Алгоритм решения
Наследуем класс Fraction от абстрактного класса Number
Реализуем все абстрактные методы: intValue(), longValue(), floatValue(), doubleValue()
Методы преобразования вычисляют десятичное значение дроби соответствующего типа

# Задание 5
## Задача 1
### Текст задачи
Разработайте метод, который принимает набор числовых значенийи возвращает их сумму в 
вещественной форме. С использованием данного метода выполните следующие сложения: 
• 2 +3/5 +2.3
• 3.6 +49/12+3 +3/2
• 1/3+ 1
### Алгоритм решения
Создаем статический метод sum с varargs параметром Number...
Итерируем по всем переданным числам и суммируем их doubleValue()
Возвращаем результат как double для сохранения точности
Метод работает с любыми типами, наследующими Number (Integer, Double, Fraction и др.)

# Задание 6
## Задача 5
### Текст задачи
Измените сущность Город, полученную в задаче 2.1.10. Переопределите метод сравнения 
объектов по состоянию таким образом, чтобы два Города считались одинаковыми тогда, когда у 
них одинаковый набор путей в другие города. Также, подвид Города из задачи 2.3.3 должен быть 
сравним с городом из задачи 2.1.10. 
### Алгоритм решения
Переопределяем методы equals() и hashCode() в классе City
Для сравнения используем имя города и набор имен соседних городов
Создаем вспомогательный метод getNeighborNames() для получения имен соседей без рекурсии
Используем Objects.equals() для безопасного сравнения и Objects.hash() для генерации хеш-кода

# Задание 7
## Задача 1
### Текст задачи
Данная задача предполагает реорганизацию ранее написанных классов. Расположите все ранее 
написанные классы по пакетам таким образом, чтобы логически близкие классы оказались 
сгруппированы друг с другом. Имена пакетов должны иметь как минимум трехсоставную форму, 
вида: ru.surname.type. Вместо surname следует подставить свою фамилию, а вместо type 
подставить название логического блока. Например, классы описывающие точку, линию, ломаную 
линию, фигуру, квадрат, треугольник, круг и прямоугольник можно расположить в пакете 
ru.surname.geometry.  
### Алгоритм решения
Создаем пакетную структуру: ru.anyanov.[fraction|city|geometry|math|main]
Группируем логически связанные классы:
fraction: Fraction
city: City, Route
geometry: Point
math: MathUtils
main: Main

## Задача 2
### Текст задачи
Создайте пакет ru.surname.main (вместо surname необходимо подставить собственную 
фамилию) в котором расположить класс с точкой входа в исполнение программы (public static void 
main). Также следует проверить, что ни в одном другом пакете нет классов имеющих точку входа 
в исполнение программы. В этом же пакете необходимо расположить класс (или интерфейс) с 
методами из задач блока 2.5 и продемонстрировать их работоспособность. 
### Алгоритм решения
Размещаем точку входа (main) только в классе Main пакета ru.anyanov.main
Создаем интерактивное меню для демонстрации всех функциональностей
Реализуем методы для ввода данных с валидацией
Демонстрируем работоспособность всех реализованных классов

## Задача 3
### Текст задачи
Создайте метод принимающий две строки, в которых будут записаны числа X и Y. Возвращает 
метод результат возведения X в степень Y. Для преобразования строки в число следует 
использовать метод Integer.parseInt, а для возведения в степень метод Math.pow. Вызовите 
разработанный метод передав туда параметры командной строки полученные точкой входа в 
программу. Реализуйте метод так, что бы для возведения в степень и преобразования строки 
использовались короткие имена статических методов.
### Алгоритм решения
Создаем метод power(String xStr, String yStr) в классе MathUtils
Используем статический импорт для Integer.parseInt и Math.pow
Преобразуем строки в числа с помощью parseInt()
Вычисляем степень с помощью pow()
Обрабатываем NumberFormatException при некорректном вводе

# Задание 8
## Задача 4
### Текст задачи
Измените сущность Точка из 2.6.2. Переопределите метод клонирования, унаследованный от 
класса Object, таким образом, чтобы при его вызове возвращался новый объект Точки, значения 
полей которого будут копиями оригинальной Точки. 
### Алгоритм решения
Реализуем интерфейс Cloneable в классе Point
Переопределяем метод clone(), вызывая super.clone()
Обрабатываем CloneNotSupportedException (невозможно в данном случае)
Возвращаем новый объект Point с такими же координатами
Демонстрируем, что изменения клона не влияют на оригинал
